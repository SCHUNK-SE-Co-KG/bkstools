# -*- coding: UTF-8 -*-
'''
Created on 21.11.2018

@author: Dirk Osswald

@brief Provides the class for generic access to SCHUNK BKS grippers via the Modbus interface
'''

import minimalmodbus
import math
from pyschunk.generated.generated_enums import eCmdCode, eErrorCode  # @UnusedImport
from pyschunk.tools.util import GetPersistantDict
from bkstools.bks_lib import hms, bks_firmware_enums
from bkstools.bks_lib.debug import Print, Error, Debug, Var, ApplicationError, InsufficientAccessRights, InsufficientReadRights, InsufficientWriteRights, ControlledFromOtherChannel, ServiceNotAvailable, UnsupportedCommand  # @UnusedImport
from bkstools.bks_lib.bks_base_common import BKSBaseCommon, Struct
import struct
import re
import os
import time

import serial
import wrapt
# Problem:
#   When reading responses from a simulated BKS gripper then the normal serial.Serial.read()
#   returns immediately after the first byte is received. This results in an error
#   "Too short Modbus RTU response (minimum length 4 bytes). Response: '\\x0e'"
#   from the minimalmodbus.
#
# Solution:
#   Override the serial.Serial.read() function to retry until timeout if not enough bytes were
#   reveived yet. This is done here by "monkey-patching" read_my() over original read.
#   See https://stackoverflow.com/a/49326472/6098953

@wrapt.patch_function_wrapper( serial.Serial, 'read' )
def read_my( read_original, self, args, kwargs):
    # args and kwargs are tuple and dict respectively.
    t0 = time.monotonic()
    t_end = t0 + self.timeout
    answer = b""
    nb_reads = 0
    nb_bytes_to_read = args[0]
    while (True):
        answer += read_original( nb_bytes_to_read )
        nb_reads += 1
        if ( len( answer ) == nb_bytes_to_read ):
            break
        if ( time.monotonic() > t_end ):
            break

    #t1 = time.monotonic()
    #print( f"read {len(answer)} bytes in {nb_reads} reads in {t1-t0}s")
    return answer

#====================================================================
class RepeaterException( minimalmodbus.ModbusException ):
    '''Class to wrap errors after a timeout or repeated tries.
    Generated by cRepeater.DoRepeat().
    When thrown then self.original_exception contains the original exception
    '''
    def __init__(self, repeater ):
        self.original_exception = repeater.original_exception
        minimalmodbus.ModbusException.__init__(self, f"RepeaterException after {repeater.timeout_checked-(repeater.end_time-repeater.timeout_s)}s (of {repeater.timeout_s}s) after {repeater.nb_failures} failures. Last exception was {repeater.original_exception!r}" )


class cRepeater(object):
    """Class to simplify retrying of some function call.
    """
    s_nb_repeaters = 0  # static counter for how many cRepeater objects were created, which is the number of reads and writes
    s_nb_total_failures  = 0  # static counter for total failures
    s_nb_repeaters_with_failures  = 0  # static counter for repeater objects with at least one failures

    def __init__( self, timeout_s=None, nb_tries=3 ):
        """Constructor: Initialize the cRepeater object with a timeout of timeout_s seconds and nb_tries number of retries
        """
        if ( timeout_s is None ):
            timeout_s = 60*60*24*365 # fake timeout one year in the future

        self.end_time    = time.time() + timeout_s
        self.timeout_s   = timeout_s
        self.nb_tries    = nb_tries
        self.tries_left  = nb_tries
        self.nb_failures = 0
        self.original_exception = None
        self.timeout_checked = 0
        cRepeater.s_nb_repeaters += 1

    def TimedOut(self):
        """Return True if timed out
        """
        self.timeout_checked = time.time()
        return (self.timeout_checked > self.end_time )

    def DoRepeat(self):
        """Call this to determine if the call should be (re)tried.
        If yes then True is returned else a RepeaterException is raised.
        """
        if ( self.tries_left < self.nb_tries                   # ensure to try once even if already timeout (e.g. due to timeout_s=0.0)
             and (self.TimedOut()  or  self.tries_left <= 0) ):
            raise RepeaterException( self )

        self.tries_left -= 1
        return True

    def Failed( self, e ):
        """Call this when a try failed with exception e
        """
        self.nb_failures += 1
        cRepeater.s_nb_total_failures += 1
        if ( self.nb_failures == 1 ):
            cRepeater.s_nb_repeaters_with_failures += 1

        self.original_exception = e
        Debug( f"Ignoring {self.nb_failures}: {e!r}")


#====================================================================
class BKS_Modbus( BKSBaseCommon ):
    def __init__(self, port, slave_id, baudrate, nb_data_bits, parity, nb_stop_bits, max_age_in_s, debug=False, repeater_timeout=3.0, repeater_nb_tries=5 ):
        self.repeater_timeout = repeater_timeout
        self.repeater_nb_tries = repeater_nb_tries
        self.format_char_read = { hms.HMS_Datatypes.ABP_BOOL  : "?",
                                  hms.HMS_Datatypes.ABP_SINT8 : "h",
                                  hms.HMS_Datatypes.ABP_SINT16: "h",
                                  hms.HMS_Datatypes.ABP_SINT32: "i",
                                  hms.HMS_Datatypes.ABP_UINT8 : "b",
                                  hms.HMS_Datatypes.ABP_UINT16: "H",
                                  hms.HMS_Datatypes.ABP_UINT32: "I",
                                  hms.HMS_Datatypes.ABP_CHAR  : "s",
                                  hms.HMS_Datatypes.ABP_ENUM  : "H",
                                  hms.HMS_Datatypes.ABP_OCTET : "H",
                                  hms.HMS_Datatypes.ABP_SINT64: "q",
                                  hms.HMS_Datatypes.ABP_UINT64: "Q",
                                  hms.HMS_Datatypes.ABP_FLOAT : "f"
                                }
        self.format_char_write = {hms.HMS_Datatypes.ABP_BOOL  : "?",
                                  hms.HMS_Datatypes.ABP_SINT8 : "b",
                                  hms.HMS_Datatypes.ABP_SINT16: "h",
                                  hms.HMS_Datatypes.ABP_SINT32: "i",
                                  hms.HMS_Datatypes.ABP_UINT8 : "H",
                                  hms.HMS_Datatypes.ABP_UINT16: "H",
                                  hms.HMS_Datatypes.ABP_UINT32: "I",
                                  hms.HMS_Datatypes.ABP_CHAR  : "s",
                                  hms.HMS_Datatypes.ABP_ENUM  : "H",
                                  hms.HMS_Datatypes.ABP_OCTET : "b",
                                  hms.HMS_Datatypes.ABP_SINT64: "q",
                                  hms.HMS_Datatypes.ABP_UINT64: "Q",
                                  hms.HMS_Datatypes.ABP_FLOAT : "f"
                                }

        host = f"{port}.{slave_id}"
        BKSBaseCommon.__init__( self, host, max_age_in_s, debug )

        #--
        # While no metadata is available via modbus use the default_settings data:
        if ( self.data is None ):
            # The default_settings is in the bkstools_data directory, which
            # is available in different places for pip and frozen exes.
            file_path = os.path.dirname( __file__ ) # start with the directory of this file

            found = False
            data_paths = []
            if ( "\\library.zip\\" in file_path ):
                # called from a frozen script
                data_path = os.path.join( file_path, "..", "..", "..", "data" )
                found = True
            else:
                # So search for the bkstools_data directory in the directory of
                # this file and all dirs above:
                while ( os.path.exists( file_path ) ):
                    data_path = os.path.join( file_path, "bkstools_data" )
                    data_paths.append( data_path )
                    if ( os.path.exists( data_path ) ):
                        found = True
                        break
                    file_path = os.path.join( file_path, ".." )

            if ( found ):
                Debug( f"found bkstools_data in {data_path!r}" )
                self.settings = GetPersistantDict( name="default_settings", path=data_path )
            else:
                Error( f"Cound not find bkstools_data directory in {data_paths!r}" )

            self.data = self.settings.setdefault( "data", None )
        #--

        self.enums[ "err_code"] = bks_firmware_enums.eErrorCode
        self.enums[ "wrn_code"] = bks_firmware_enums.eErrorCode
        self.enums[ "fieldbus_type" ] = bks_firmware_enums.eFieldbusType
        self.enums[ "actual_user" ] = bks_firmware_enums.eBksUserLevel

        self.mb = minimalmodbus.Instrument( port, slave_id, debug=debug )  # port name, slave address (in decimal)

        def _my_print_debug(text: str) -> None:
            if self.mb.debug:
                #_print_out("MinimalModbus debug mode. " + text)
                now = time.time()
                ms = str( math.modf( now )[0] )[1:5]
                if ( self.mb.debug ):
                    print( time.strftime( "%H:%M:%S.", time.localtime( now) ) + ms + " " "MinimalModbus " + text )
        self.mb._print_debug = _my_print_debug


        #self.mb.serial.port                     # this is the serial port name
        self.mb.serial.baudrate = baudrate
        self.mb.serial.bytesize = nb_data_bits
        if ( parity == "N" ):
            self.mb.serial.parity   = minimalmodbus.serial.PARITY_NONE
        elif ( parity == "E" ):
            self.mb.serial.parity   = minimalmodbus.serial.PARITY_EVEN
        elif ( parity == "O" ):
            self.mb.serial.parity   = minimalmodbus.serial.PARITY_ODD
        else:
            raise ValueError( f"Parity {parity!r} not understood, must be one of N E O.")
        self.mb.serial.stopbits = nb_stop_bits
        self.mb.serial.timeout  = 0.050          # seconds
        #self.mb.serial.timeout  = 0.500           # seconds

        #self.mb.address                         # this is the slave address number
        self.mb.mode = minimalmodbus.MODE_RTU   # rtu or ascii mode
        self.mb.clear_buffers_before_each_transaction = True
        self.byteorder = minimalmodbus.BYTEORDER_LITTLE
        if ( self.byteorder == minimalmodbus.BYTEORDER_LITTLE ):
            self.byteorder_prefix = ">"
        else:
            self.byteorder_prefix = "<"

        #print( self.enums[ "fieldbus_type" ] )
        #print( self.fieldbus_type )

        baudrate = dict( instance=0x11a0,
                         numelements=1,
                         datatype=[hms.HMS_Datatypes.ABP_UINT32],
                         #descriptor' (81553072)    <class 'list'>: [3]
                         name="baudrate",
                         max=12000000,
                         min=1200,
                         default=115200,
                         numsubelements=None,
                         elementname=None )

        slave_id = dict( instance=0x11a8,
                         numelements=1,
                         datatype=[hms.HMS_Datatypes.ABP_UINT16],
                         #descriptor' (81553072)    <class 'list'>: [3]
                         name="slave_id",
                         max=247,
                         min=1,
                         default=12,
                         numsubelements=None,
                         elementname=None )


        # alternative names for "slave_id"
        slave_id_write2 = dict( instance=0x11a8,
                                numelements=2,
                                datatype=[hms.HMS_Datatypes.ABP_UINT16],
                                #descriptor' (81553072)    <class 'list'>: [3]
                                name="slave_id_write2",
                                max=247,
                                min=1,
                                default=12,
                                numsubelements=None,
                                elementname=None )
        slave_id_write6 = dict( instance=0x11a8,
                                numelements=6,
                                datatype=[hms.HMS_Datatypes.ABP_UINT16],
                                #descriptor' (81553072)    <class 'list'>: [3]
                                name="slave_id_write6",
                                max=0,
                                min=65535,
                                default=0,
                                numsubelements=None,
                                elementname=None )

        self.SetAttributes( extra_parameter_dicts=[ baudrate, slave_id, slave_id_write2, slave_id_write6 ] )

        self.UpdateMetadata()

        self.SetFieldbus()

        self.SetupControlword()
        self.SetupStatusword()



    def UpdateMetadata( self ):
        pass # TODO: for now Modbus does not update. But it should once meta-info can be read via Modbus

    def UpdateEnum( self, d):
        pass # TODO: for now Modbus does not update. But it should once meta-info can be read via Modbus

    def SetFieldbus(self):
        self.reverse_data = False
        #self.fieldbus_type = 7


    def Serialize( self, index, datatype, value ):
        format_char_write = self.format_char_write[ datatype ]
        try:
            if ( datatype == hms.HMS_Datatypes.ABP_CHAR ):
                bytestring = bytes( value, "Cp1252" )
            else:
                bytestring = struct.pack( f"<{format_char_write}", value )
            if ( len( bytestring ) & 1 ):
                # its an odd length, so append extra 0 byte:
                bytestring += b'\x00'
            return bytestring
        except struct.error:
            # workaround for set_pos not beeing an UINT32
            if ( index == 1  and  value < 0 ):
                return struct.pack( f"<i", value )
            else:
                raise

    def set_value( self, index_or_name, datatype=None, value=None, elementindices=None ):
        #print( f"set_value( {Var('index_or_name datatype value elementindices')}" )

        if ( (type( index_or_name ) is str  and  "." in index_or_name)  or not elementindices is None ):
            # its a structured parameter and only a single element is accessed:
            if ( type( index_or_name ) is str  and  "." in index_or_name ):
                (name,subname) = index_or_name.split(".")
                index = self.MakeIndex( name  )
                e = self.data[index]["elementname"].index( subname )
            else:
                index = self.MakeIndex( index_or_name  )
                e = elementindices

            datatype = self.data[index]["datatype"][e]
            raise NotImplementedError( f"single element access to structured parameter {index_or_name} not implemented")

        if ( type(value) in (Struct,tuple) ):
            # its a structure and all elements are given
            index = self.MakeIndex( index_or_name  )
            bytestring = b""
            for ei in range( len( self.data[index]["datatype"] ) ):
                datatype = self.data[index]["datatype"][ei]
                elementname = self.data[index]["elementname"][ei]
                if ( type( value ) is tuple ):
                    elementvalue = value[ei]
                else:
                    elementvalue = value.__dict__[ elementname ]
                bytestring += self.Serialize( index, datatype, elementvalue )

            register_value_list = list( struct.unpack( f"{len(bytestring)}H", bytestring ) )
            parameter_id = self.data[ index ]["instance"]
            register_address = parameter_id - 1
            return self.mb.write_registers( register_address, register_value_list )

        if ( type( index_or_name ) is str  and  "[" in index_or_name ):
            mob = re.match( "(\w+)\[(.+)\]", index_or_name )
            elementindices = [eval(mob.group(2))]
            index_or_name = mob.group(1)

        index = self.MakeIndex( index_or_name )

        if ( elementindices is None ):
            elementindices = list(range( self.data[index]["numelements" ]))

        if ( datatype is None ):
            if ( len( self.data[index]["datatype"] ) == 1 ):
                # array or normal variable
                datatype = self.data[index]["datatype"][0]

        inst = self.data[ index ]["instance"]

        if ( self.data[index]["numelements" ] > 1 ):
            #its an array
            len_value = 1
            try:
                len_value = len( value )
            except TypeError:
                pass

            if ( len_value == 1 ):
                # only a single value is given, so forward that to all array elements
                value = [value] * len(elementindices)

            if ( datatype == hms.HMS_Datatypes.ABP_CHAR ):
                bytestring = self.Serialize( index, datatype, value )
                register_value_list = list( struct.unpack( f"{self.byteorder_prefix}{len(bytestring)>>1}H", bytestring ) )
                parameter_id = self.data[ index ]["instance"]
                register_address = parameter_id - 1
                return self.mb.write_registers( register_address, register_value_list )

            if ( len( value ) != len( elementindices ) ):
                raise ApplicationError( "Number of values to set for array does not match! Expected 1 or %d values, but not %d" % (self.data[index]["numelements" ],len(value)) )

            if ( len( elementindices ) == self.data[ index]["numelements"] ):
                # whole array is given
                bytestring = b""
                for v in value:
                    bytestring += self.Serialize( index, datatype, v )
                register_value_list = list( struct.unpack( f"{self.byteorder_prefix}{len(bytestring)>>1}H", bytestring ) )
                parameter_id = self.data[ index ]["instance"]
                register_address = parameter_id - 1
                return self.mb.write_registers( register_address, register_value_list )
            else:
                #raise NotImplementedError( f"Partial array writing not supported on Modbus for parameter {index_or_name}!" )
                # read whole array first:
                read_values = self.UpdateValue( index_or_name, datatype, index )
                for (e,v) in zip( elementindices, value ):
                    # overwrite a part:
                    read_values[e] = v
                # write back:
                return self.set_value( index_or_name, datatype, read_values, elementindices=None )
            return

        index = self.MakeIndex( index_or_name  )
        parameter_id = self.data[ index ]["instance"]
        register_address = parameter_id - 1

        if ( datatype is None ):
            if ( len( self.data[index]["datatype"] ) == 1 ):
                # array or normal variable
                datatype = self.data[index]["datatype"][0]

        # its a single value:
        bytestring = self.Serialize( index, datatype, value )
        register_value_list = list( struct.unpack( f"{self.byteorder_prefix}{(len(bytestring)+1)>>1}H", bytestring ) )
        parameter_id = self.data[ index ]["instance"]
        register_address = parameter_id - 1

        repeater = cRepeater( self.repeater_timeout, self.repeater_nb_tries )
        while repeater.DoRepeat():
            try:
                return self.mb.write_registers( register_address, register_value_list )
            except minimalmodbus.ModbusException as e:
                repeater.Failed( e )

    def GetStructuredValue( self, index ):
        s = Struct()

        struct_size = 0
        for (datatype,numsubelements) in zip( self.data[index]["datatype"], self.data[index]["numsubelements"]):
            struct_size += hms.HMS_Datatypes_size_in_bytes[ datatype ] * numsubelements

        register_address = self.data[index]["instance"] - 1
        nb_registers = (struct_size+1) >> 1
        repeater = cRepeater( self.repeater_timeout, self.repeater_nb_tries )
        while repeater.DoRepeat():
            try:
                data_words = self.mb.read_registers( register_address, nb_registers )
                # data_words is now a list of 16 bit ints
                break
            except minimalmodbus.ModbusException as e:
                repeater.Failed( e )

        byte_list = b""
        for w in data_words:
            byte_list += bytes( [w >> 8, w & 0x00ff ] )
        # byte_list is now a bytes of received byte values

        try:
            #for si in range( len( self.data[index]["datatype"] ) ):
            si = 0
            byte_index = 0
            for (datatype,numsubelements,elementname) in zip( self.data[index]["datatype"],
                                                              self.data[index]["numsubelements"],
                                                              self.data[index]["elementname"] ):

                nb_bytes = numsubelements * hms.HMS_Datatypes_size_in_bytes[ datatype ]
                value = self.ByteListToValue( byte_list[byte_index:byte_index+nb_bytes], datatype, numsubelements)

                s.AddOrdered( elementname,
                              value,
                              self,
                              index,
                              si )
                byte_index += nb_bytes
                si += 1
        except InsufficientAccessRights as e:
            raise #reraise to let caller handle that withut clutter

        except Exception as e:
            # for easy debugging:
            Error( f"GetStructuredValue( index={index} ) failed with {e!r}\n  byte_list={byte_list!r}" )
            raise

        return s

    def RegisterListToValue( self, data, datatype, numelements ):
        byte_list = struct.pack( f"{self.byteorder_prefix}{len(data)}H", *data )
        return self.ByteListToValue( byte_list, datatype, numelements )

    def ByteListToValue(self, byte_list, datatype, numelements ):
        format_char_read = self.format_char_read[ datatype ]
        if ( format_char_read == "s"  and  len( byte_list ) == numelements + 1 ):
            # strings of odd length are transmitted with one extra byte in the end.
            # so strip that off
            byte_list = byte_list[:-1]
        if ( format_char_read == "?"  and  len( byte_list ) == 2 ):
            # single bools are transmitted as one Modbus register with 16 bit
            format_char_read = "H"
        result_list = struct.unpack( f"<{numelements}{format_char_read}", byte_list )
        if ( format_char_read == "s" ):
            return result_list[0].decode('cp850')
        if ( numelements == 1 ):
            return result_list[0]
        return list(result_list)

    def UpdateValue( self, index_or_name, datatype, index ):
        parameter_id = self.data[ index ]["instance"]
        register_address = parameter_id - 1
        #print( f"UpdateValue( {Var('index_or_name datatype index')} 0x{parameter_id:x}" )

        numelements = self.data[index]["numelements"]

        if ( len( self.data[index]["datatype"] ) > 1 ):
            return self.GetStructuredValue(index)

        nb_registers = (hms.HMS_Datatypes_size_in_bytes[ datatype ]*numelements + 1) >> 1

        repeater = cRepeater( self.repeater_timeout, self.repeater_nb_tries )
        while repeater.DoRepeat():
            try:
                data = self.mb.read_registers( register_address, nb_registers )
                # data is now a list of 16 bit ints
                break
            except minimalmodbus.ModbusException as e:
                repeater.Failed( e )

        return self.RegisterListToValue( data, datatype, numelements )

    def ReadExceptionStatus(self):
        """Read the Modbus-RTU exception status using function 7
        """
        return ord( self.mb._perform_command( 7, "" ) )

    def SetResponseExpectancy( self, response_expectancy ):
        """Set the SCHUNK addition "response_expectancy" via the function code 08 "diagnostics" sub-function 0x0004 "Force Listen Only Mode"
        """
        sub_function = 0x0004
        byte_list = struct.pack( f">HH", sub_function, response_expectancy )
        try:
            self.mb._perform_command( 8, byte_list )
        except minimalmodbus.ModbusException:
            # there is no response
            pass
