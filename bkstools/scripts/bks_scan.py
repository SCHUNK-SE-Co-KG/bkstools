#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Created on 2022-04-08
#
# @author: Dirk Osswald
'''
Scan for Modbus-RTU devices.|n
|n
Example usage:|n
-  %(prog)s -H COM3|n
'''

import os.path
import sys
import pyschunk.tools.mylogger

from bkstools.bks_lib.bks_base import BKSBase, GetModbusSettings
from bkstools.bks_lib.debug import Print, SetShowDebug
from bkstools.bks_lib.debug import InsufficientWriteRights  # @UnusedImport
from bkstools.bks_lib.debug import g_logmethod              # @UnusedImport

import minimalmodbus


logger = pyschunk.tools.mylogger.getLogger( "BKSTools.bks_device_scan" )
pyschunk.tools.mylogger.setupLogging()
g_logmethod = logger.info

from bkstools.bks_lib import bks_options


def ScanID( bks, mb_id, parametername, nb_rescans, response_expectancy ):
    """Try to read the parameter named parametername from the slave with ID mb_id up to nb_rescans times.
    Return the first value found or None if no one answered
    """
    Print( f"Trying {mb_id} ... ", end="" )

    bks.mb.address = mb_id
    SetShowDebug( False )
    for i in range(0,nb_rescans):  # @UnusedVariable
        try:
            value = bks.get_value( parametername )
            return value
        except minimalmodbus.ModbusException as e:  # @UnusedVariable
            # nothing or garbage received, so try with higher response_expectancy
            bks.SetResponseExpectancy( response_expectancy )
    Print( f"no" )
    return None


def ScanIDs( bks, scan_id_range, nb_rescans, response_expectancy ):
    scan_ids = pyschunk.tools.util.RangeDefToList( scan_id_range )

    Print( f"Step 1/2: Start initial scanning for Modbus-RTU devices on IDs {scan_id_range}" )

    serial_no_txts = dict()
    serial_no_nums = dict()
    for mb_id in scan_ids:
        serial_no_num = ScanID( bks, mb_id, "serial_no_num", nb_rescans, response_expectancy )

        if ( not serial_no_num is None ):
            Print( "found!")
            serial_no_nums[ mb_id ] = {serial_no_num}

    found_ids = list( serial_no_nums.keys() )
    found_ids.sort()
    Print( f"\nStep 2/2: Rescanning for Modbus-RTU devices with colliding IDs on found IDs {found_ids}" )

    # For rescanning try with higher response_expectancy right away:
    bks.SetResponseExpectancy( response_expectancy )

    for mb_id in found_ids:
        for i in range(0,nb_rescans):  # @UnusedVariable
            serial_no_num = ScanID( bks, mb_id, "serial_no_num", nb_rescans, response_expectancy )
            if ( not serial_no_num is None  ):
                serial_no_nums[ mb_id ].add( serial_no_num )

            serial_no_txt = ScanID( bks, mb_id, "serial_no_txt", nb_rescans, response_expectancy )
            if ( not serial_no_txt is None  ):
                if ( mb_id in serial_no_txts ):
                    serial_no_txts[ mb_id ].add( serial_no_txt )
                else:
                    serial_no_txts[ mb_id ] = {serial_no_txt}

    Print( "" )

    Print( "\nFinal results:" )
    colliding_ids = []
    for mb_id in found_ids:
        sn_nums = ""
        sep = ""
        for sn_num in serial_no_nums[ mb_id ]:
            sn_nums += sep + f"0x{sn_num:08x}"
            sep = ", "

        sn_txts = ""
        sep = ""
        for sn_txt in serial_no_txts[ mb_id ]:
            sn_txt = sn_txt.strip(' \t\0')
            sn_txts += sep + f"{sn_txt!r}"
            sep = ", "

        nb_slaves = max( len( serial_no_nums[ mb_id ] ), len( serial_no_txts[ mb_id ] ) )
        Print( f"  Found {nb_slaves} slave(s) with ID {mb_id}. Serial numbers {sn_nums} ({sn_txts})")
        if ( nb_slaves > 1 ):
            colliding_ids.append( mb_id )

    if ( len( colliding_ids ) > 0 ):
        Print( f"  Found {len(colliding_ids)} slave IDs used by multiple devices: {colliding_ids!r} => colliding IDs!!! ")
    else:
        Print( f"  Found no slave IDs used by multiple devices. Slave_id mapping seems to be ok.")

    return (found_ids, colliding_ids)


def ResolveCollisions( found_ids, colliding_ids ):
    if ( len(colliding_ids) == 0 ):
        return

    #for colliding_id in colliding_ids:


def main():
    if ( "__file__" in globals() ):
        prog = os.path.basename( globals()["__file__"] )
    else:
        # when runnging as an exe generated by py2exe then __file__ is not defined!
        prog = "bks_scan.exe"

    parser = bks_options.cBKSTools_OptionParser( prog=prog,
                                                 description = __doc__ )    # @UndefinedVariable

    parser.add_argument( '-i', "--ids",
                         dest="scan_ids",
                         default="1-247",
                         type=str,
                         help="""The slave IDs to scan. Can be a single ID like "12", a list of comma separated indices like "1,2,3", a range like "1-20" or a combination of the latter. Default is %(default)s to scan for all IDs.""" )

    parser.add_argument( '-n', "--nb_rescans",
                         dest="nb_rescans",
                         default=5,
                         type=int,
                         help="""The number of rescan tries. Default is %(default)d.""" )

    parser.add_argument( '-e', "--nb_expected", "--response_expectancy",
                         dest="response_expectancy",
                         default=2,
                         type=int,
                         help="""The response expectancy (likelihood for sending a response) to set. This can be used to make slaves respond with a probability of 1/response_expectancy only.
                         If you expect to find 2 slaves with colliding slave-ID then set this to 2, for 3 to 3 and so on. Default is %(default)d.""" )



    args = parser.parse_args()

    if ( GetModbusSettings( args.host ) is None ):
        print( f"Scanning works for Modbus-RTU devices only!\n{args.host!r} does not denote a serial interface to use for communication." )
        return 1
    bks = BKSBase( args.host, debug=args.debug, repeater_timeout=args.repeat_timeout, repeater_nb_tries=1 )

    (found_ids, colliding_ids) = ScanIDs( bks, args.scan_ids, args.nb_rescans, args.response_expectancy )

    ResolveCollisions( found_ids, colliding_ids )

if __name__ == '__main__':
    from pyschunk.tools import attach_to_debugger
    rc = attach_to_debugger.AttachToDebugger( main )
    sys.exit( rc )
    #main()
