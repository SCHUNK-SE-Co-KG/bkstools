#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Created on 18.10.2018
#
# @author: Dirk Osswald
'''
Perform a cycle of grip and release movements with a BKS gripper (like EGI/EGU/EGK)|n
|n
On call the script will:|n
- acknowledge pending errors (if required),|n
- normal grip from outside to determine workpiece position|n
- release|n
- repeat in loop:|n
  - grip with position|n
  - release|n
|n
Example usage:|n
-  %(prog)s -H 10.49.57.13

-  %(prog)s -H COM3,12

'''

import os.path

import pyschunk.tools.mylogger
from bkstools.bks_lib.bks_base import keep_communication_alive_input
from bkstools.bks_lib.bks_module import BKSModule, HandleWarningPrintOnly  # @UnusedImport
from bkstools.bks_lib.debug import Print, Var, ApplicationError, g_logmethod  # @UnusedImport


logger = pyschunk.tools.mylogger.getLogger( "BKSTools.demo.demo_grip_workpiece_with_position" )
pyschunk.tools.mylogger.setupLogging()
g_logmethod = logger.info

from bkstools.bks_lib import bks_options


def main():
    if ( "__file__" in globals() ):
        prog = os.path.basename( globals()["__file__"] )
    else:
        # when runnging as an exe generated by py2exe then __file__ is not defined!
        prog = "demo_grip_workpiece_with_expected_position.exe"

    parser = bks_options.cBKSTools_OptionParser( prog=prog,
                                                 description = __doc__,   # @UndefinedVariable
                                                 additional_arguments=[ "grip_velocity",
                                                                        "force" ] )

    args = parser.parse_args()


    #--- Create a BKSBase object to interact with the gripper:
    bks = BKSModule( args.host,
                     sleep_time=None,
                     #handle_warning=HandleWarningPrintOnly
                     debug=args.debug,
                     repeater_timeout=args.repeat_timeout,
                     repeater_nb_tries=args.repeat_nb_tries
                   )

    def my_input( prompt ):
        '''alias
        '''
        return keep_communication_alive_input( bks, prompt )



    Print( "Make ready...")
    bks.MakeReady()

    bks.move_to_absolute_position( 50000, 50000 )
    my_input( "Insert object to grip and press enter")

    move_rel_velocity_ums = int( bks.max_vel * 1000.0 )
    force_percent = args.force
    if ( args.grip_velocity is None ):
        # BasicGrip: use default grip velocity stored in gripper:
        grip_velocity_ums = 0
    else:
        # SoftGrip: use the provided velocity:
        grip_velocity_ums = int( args.grip_velocity * 1000.0 )
    #grip_direction = BKSModule.grip_from_inside
    grip_direction = BKSModule.grip_from_outside

    bks.vel = grip_velocity_ums      # should be sufficient, but is not if no absolute/relative movement was executed before
    #bks.set_vel = args.grip_velocity # workaround to make gripping work

    bks.grip_workpiece( grip_direction, grip_velocity_ums, force_percent )

    workpiece_position_mm = bks.actual_pos
    Print( f"grip_workpiece: Found Workpiece at {workpiece_position_mm:.1f}mm" )

    bks.release_workpiece()

    position_mm = bks.actual_pos
    Print( f"release_workpiece: released to {position_mm:.1f}mm" )

    # move away a little more:
    rpos_mm = bks.grp_pos_margin
    if ( grip_direction == BKSModule.grip_from_inside ):
        rpos_mm = -rpos_mm
    bks.move_to_relative_position( int(rpos_mm*1000.0), move_rel_velocity_ums )

    position_mm = bks.actual_pos
    Print( f"move_to_relative_position: to {position_mm:.1f}mm" )

    n=0
    while True:
        n += 1
        Print( f"Loop %d..." % n)

        bks.grip_workpiece_with_expected_position( grip_direction, int(workpiece_position_mm*1000.0), grip_velocity_ums, force_percent, wait_command_successfully_processed_timeout=2.0 )

        position_mm = bks.actual_pos
        Print( f"grip_workpiece_with_position: Found Workpiece at {position_mm:.1f}mm" )

        bks.release_workpiece()

        position_mm = bks.actual_pos
        Print( f"release_workpiece: released to {position_mm:.1f}mm" )


if __name__ == '__main__':
    from pyschunk.tools import attach_to_debugger
    attach_to_debugger.AttachToDebugger( main )
    #main()
